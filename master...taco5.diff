diff --git a/selfdrive/car/hyundai/carcontroller.py b/selfdrive/car/hyundai/carcontroller.py
index 5582499f25b29..34cc65158009c 100644
--- a/selfdrive/car/hyundai/carcontroller.py
+++ b/selfdrive/car/hyundai/carcontroller.py
@@ -60,8 +60,10 @@ def update(self, CC, CS):
 
     # steering torque
     steer = actuators.steer
+    self.params = CarControllerParams(self.CP, CS.out.vEgoRaw)
     new_steer = int(round(steer * self.params.STEER_MAX))
     apply_steer = apply_std_steer_torque_limits(new_steer, self.apply_steer_last, CS.out.steeringTorque, self.params)
+    apply_steer = clip(apply_steer, -self.params.STEER_MAX, self.params.STEER_MAX)
 
     if not CC.latActive:
       apply_steer = 0
diff --git a/selfdrive/car/hyundai/carstate.py b/selfdrive/car/hyundai/carstate.py
index fc196528d7116..2a500fc1e0515 100644
--- a/selfdrive/car/hyundai/carstate.py
+++ b/selfdrive/car/hyundai/carstate.py
@@ -191,8 +191,8 @@ def update_canfd(self, cp, cp_cam):
     ret.steeringPressed = self.update_steering_pressed(abs(ret.steeringTorque) > self.params.STEER_THRESHOLD, 5)
     ret.steerFaultTemporary = cp.vl["MDPS"]["LKA_FAULT"] != 0
 
-    ret.leftBlinker, ret.rightBlinker = self.update_blinker_from_lamp(50, cp.vl["BLINKERS"]["LEFT_LAMP"],
-                                                                      cp.vl["BLINKERS"]["RIGHT_LAMP"])
+    ret.leftBlinker, ret.rightBlinker = self.update_blinker_from_lamp(200, cp.vl["BLINKER_STALKS"]["LEFT_BLINKER"],
+                                                                      cp.vl["BLINKER_STALKS"]["RIGHT_BLINKER"])
     if self.CP.enableBsm:
       ret.leftBlindspot = cp.vl["BLINDSPOTS_REAR_CORNERS"]["FL_INDICATOR"] != 0
       ret.rightBlindspot = cp.vl["BLINDSPOTS_REAR_CORNERS"]["FR_INDICATOR"] != 0
@@ -441,8 +441,8 @@ def get_can_parser_canfd(CP):
       ("ADAPTIVE_CRUISE_MAIN_BTN", cruise_btn_msg),
       ("DISTANCE_UNIT", "CRUISE_BUTTONS_ALT"),
 
-      ("LEFT_LAMP", "BLINKERS"),
-      ("RIGHT_LAMP", "BLINKERS"),
+      ("LEFT_BLINKER", "BLINKER_STALKS"),
+      ("RIGHT_BLINKER", "BLINKER_STALKS"),
 
       ("DRIVER_DOOR_OPEN", "DOORS_SEATBELTS"),
       ("DRIVER_SEATBELT_LATCHED", "DOORS_SEATBELTS"),
@@ -455,7 +455,7 @@ def get_can_parser_canfd(CP):
       ("MDPS", 100),
       ("TCS", 50),
       ("CRUISE_BUTTONS_ALT", 50),
-      ("BLINKERS", 4),
+      ("BLINKER_STALKS", 1),
       ("DOORS_SEATBELTS", 4),
     ]
 
diff --git a/selfdrive/car/hyundai/interface.py b/selfdrive/car/hyundai/interface.py
index 811d629f70ecb..868dd7e101c04 100644
--- a/selfdrive/car/hyundai/interface.py
+++ b/selfdrive/car/hyundai/interface.py
@@ -176,6 +176,7 @@ def _get_params(ret, candidate, fingerprint, car_fw, experimental_long):
       ret.wheelbase = 2.9
       ret.steerRatio = 16.
       tire_stiffness_factor = 0.65
+      ret.flags |= HyundaiFlags.ENABLE_BLINKERS.value
     elif candidate == CAR.IONIQ_5:
       ret.mass = 2012 + STD_CARGO_KG
       ret.wheelbase = 3.0
diff --git a/selfdrive/car/hyundai/values.py b/selfdrive/car/hyundai/values.py
index cdcaf629af67c..79de0f681ac73 100644
--- a/selfdrive/car/hyundai/values.py
+++ b/selfdrive/car/hyundai/values.py
@@ -16,7 +16,7 @@ class CarControllerParams:
   ACCEL_MIN = -3.5 # m/s
   ACCEL_MAX = 2.0 # m/s
 
-  def __init__(self, CP):
+  def __init__(self, CP, vEgoRaw=100.):
     self.STEER_DELTA_UP = 3
     self.STEER_DELTA_DOWN = 7
     self.STEER_DRIVER_ALLOWANCE = 50
@@ -25,12 +25,12 @@ def __init__(self, CP):
     self.STEER_THRESHOLD = 150
 
     if CP.carFingerprint in CANFD_CAR:
-      self.STEER_MAX = 270
-      self.STEER_DRIVER_ALLOWANCE = 250
+      self.STEER_MAX = 384 if vEgoRaw < 11. else 330
+      self.STEER_DRIVER_ALLOWANCE = 350
       self.STEER_DRIVER_MULTIPLIER = 2
-      self.STEER_THRESHOLD = 250
-      self.STEER_DELTA_UP = 2
-      self.STEER_DELTA_DOWN = 3
+      self.STEER_THRESHOLD = 350
+      self.STEER_DELTA_UP = 10 if vEgoRaw < 11. else 2
+      self.STEER_DELTA_DOWN = 10 if vEgoRaw < 11. else 3
 
     # To determine the limit for your car, find the maximum value that the stock LKAS will request.
     # If the max stock LKAS request is <384, add your car to this list.
diff --git a/selfdrive/controls/controlsd.py b/selfdrive/controls/controlsd.py
index 36f0b559c2eaa..86bc3ac4f39ad 100755
--- a/selfdrive/controls/controlsd.py
+++ b/selfdrive/controls/controlsd.py
@@ -8,6 +8,7 @@
 from common.realtime import sec_since_boot, config_realtime_process, Priority, Ratekeeper, DT_CTRL
 from common.profiler import Profiler
 from common.params import Params, put_nonblocking
+from common.filter_simple import FirstOrderFilter
 import cereal.messaging as messaging
 from common.conversions import Conversions as CV
 from panda import ALTERNATIVE_EXPERIENCE
@@ -90,7 +91,7 @@ def __init__(self, sm=None, pm=None, can_sock=None, CI=None):
         ignore += ['roadCameraState']
       self.sm = messaging.SubMaster(['deviceState', 'pandaStates', 'peripheralState', 'modelV2', 'liveCalibration',
                                      'driverMonitoringState', 'longitudinalPlan', 'lateralPlan', 'liveLocationKalman',
-                                     'managerState', 'liveParameters', 'radarState', 'liveTorqueParameters', 'testJoystick'] + self.camera_packets,
+                                     'managerState', 'liveParameters', 'radarState', 'liveTorqueParameters', 'testJoystick', 'navInstruction'] + self.camera_packets,
                                     ignore_alive=ignore, ignore_avg_freq=['radarState', 'longitudinalPlan', 'testJoystick'])
 
     if CI is None:
@@ -186,6 +187,12 @@ def __init__(self, sm=None, pm=None, can_sock=None, CI=None):
     self.desired_curvature_rate = 0.0
     self.v_cruise_helper = VCruiseHelper(self.CP)
 
+    self.laneline_filters = [FirstOrderFilter(0., 2., 0.05) for _ in range(4)]
+    self.last_on_ramp_right = False
+    self.last_on_ramp_right_timer = 0.0
+    self.last_lane_change_dir = LaneChangeDirection.none
+    self.last_lane_change_frame = 0.
+
     # TODO: no longer necessary, aside from process replay
     self.sm['liveParameters'].valid = True
 
@@ -219,6 +226,36 @@ def set_initial_state(self):
       if any(ps.controlsAllowed for ps in self.sm['pandaStates']):
         self.state = State.enabled
 
+  def handle_nav_lane_changes(self, CS):
+    if self.sm.updated['modelV2']:
+      for i in range(4):
+        self.laneline_filters[i].update(self.sm['modelV2'].laneLineProbs[i])
+    if self.sm['navInstruction'].maneuverType in ('on ramp', 'turn') and self.sm['navInstruction'].maneuverModifier == 'right':
+      self.last_on_ramp_right = True
+      self.last_on_ramp_right_timer = 0.0
+
+    self.last_on_ramp_right_timer += DT_CTRL if self.last_on_ramp_right else 0.0
+    if (self.last_on_ramp_right and self.sm['lateralPlan'].laneChangeState == LaneChangeState.laneChangeFinishing) or \
+       self.last_on_ramp_right_timer > 60:
+      self.last_on_ramp_right = False
+      self.last_on_ramp_right_timer = 0.0
+
+    desired_dir = LaneChangeDirection.none
+    if CS.vEgo > 18.:
+      if self.laneline_filters[0].x > 0.3 and self.last_on_ramp_right and self.last_on_ramp_right_timer > 2.0:
+        desired_dir = LaneChangeDirection.left
+      elif self.laneline_filters[3].x > 0.5 and self.sm['navInstruction'].maneuverType == 'off ramp' and \
+           self.sm['navInstruction'].maneuverModifier == 'right' and self.sm['navInstruction'].maneuverDistance < (1.5 * 1609.34):
+        desired_dir = LaneChangeDirection.right
+
+    CS = CS.as_builder()
+    if (desired_dir != LaneChangeDirection.none) and ((self.last_lane_change_dir == desired_dir) or (self.sm.frame - self.last_lane_change_frame)*DT_CTRL > 15.0):
+      CS.leftBlinker = CS.leftBlinker or (desired_dir == LaneChangeDirection.left)
+      CS.rightBlinker = CS.rightBlinker or (desired_dir == LaneChangeDirection.right)
+      self.last_lane_change_dir = desired_dir
+      self.last_lane_change_frame = self.sm.frame
+    return CS.as_reader()
+
   def update_events(self, CS):
     """Compute carEvents from carState"""
 
@@ -428,6 +465,7 @@ def data_sample(self):
     CS = self.CI.update(self.CC, can_strs)
 
     self.sm.update(0)
+    CS = self.handle_nav_lane_changes(CS)
 
     if not self.initialized:
       all_valid = CS.canValid and self.sm.all_checks()
diff --git a/selfdrive/controls/lib/desire_helper.py b/selfdrive/controls/lib/desire_helper.py
index 4790b8f0ebf68..47987f5925de9 100644
--- a/selfdrive/controls/lib/desire_helper.py
+++ b/selfdrive/controls/lib/desire_helper.py
@@ -37,6 +37,7 @@ def __init__(self):
     self.lane_change_timer = 0.0
     self.lane_change_ll_prob = 1.0
     self.keep_pulse_timer = 0.0
+    self.lane_change_pulse_timer = 0.0
     self.prev_one_blinker = False
     self.desire = log.LateralPlan.Desire.none
 
@@ -56,20 +57,17 @@ def update(self, carstate, lateral_active, lane_change_prob):
 
       # LaneChangeState.preLaneChange
       elif self.lane_change_state == LaneChangeState.preLaneChange:
+        self.lane_change_pulse_timer += DT_MDL
         # Set lane change direction
         self.lane_change_direction = LaneChangeDirection.left if \
           carstate.leftBlinker else LaneChangeDirection.right
 
-        torque_applied = carstate.steeringPressed and \
-                         ((carstate.steeringTorque > 0 and self.lane_change_direction == LaneChangeDirection.left) or
-                          (carstate.steeringTorque < 0 and self.lane_change_direction == LaneChangeDirection.right))
-
         blindspot_detected = ((carstate.leftBlindspot and self.lane_change_direction == LaneChangeDirection.left) or
                               (carstate.rightBlindspot and self.lane_change_direction == LaneChangeDirection.right))
 
         if not one_blinker or below_lane_change_speed:
           self.lane_change_state = LaneChangeState.off
-        elif torque_applied and not blindspot_detected:
+        elif self.lane_change_pulse_timer > 2. and not blindspot_detected:
           self.lane_change_state = LaneChangeState.laneChangeStarting
 
       # LaneChangeState.laneChangeStarting
@@ -93,6 +91,8 @@ def update(self, carstate, lateral_active, lane_change_prob):
           else:
             self.lane_change_state = LaneChangeState.off
 
+    if self.lane_change_state in (LaneChangeState.laneChangeFinishing, LaneChangeState.off):
+      self.lane_change_pulse_timer = 0.0
     if self.lane_change_state in (LaneChangeState.off, LaneChangeState.preLaneChange):
       self.lane_change_timer = 0.0
     else:
diff --git a/selfdrive/controls/lib/events.py b/selfdrive/controls/lib/events.py
index 3036828662523..2d4c0afaf4878 100644
--- a/selfdrive/controls/lib/events.py
+++ b/selfdrive/controls/lib/events.py
@@ -512,7 +512,7 @@ def joystick_alert(CP: car.CarParams, CS: car.CarState, sm: messaging.SubMaster,
 
   EventName.preLaneChangeLeft: {
     ET.WARNING: Alert(
-      "Steer Left to Start Lane Change Once Safe",
+      "Left Lane Change Starting",
       "",
       AlertStatus.normal, AlertSize.small,
       Priority.LOW, VisualAlert.none, AudibleAlert.none, .1, alert_rate=0.75),
@@ -520,7 +520,7 @@ def joystick_alert(CP: car.CarParams, CS: car.CarState, sm: messaging.SubMaster,
 
   EventName.preLaneChangeRight: {
     ET.WARNING: Alert(
-      "Steer Right to Start Lane Change Once Safe",
+      "Right Lane Change Starting",
       "",
       AlertStatus.normal, AlertSize.small,
       Priority.LOW, VisualAlert.none, AudibleAlert.none, .1, alert_rate=0.75),
@@ -530,7 +530,7 @@ def joystick_alert(CP: car.CarParams, CS: car.CarState, sm: messaging.SubMaster,
     ET.WARNING: Alert(
       "Car Detected in Blindspot",
       "",
-      AlertStatus.userPrompt, AlertSize.small,
+      AlertStatus.normal, AlertSize.small,
       Priority.LOW, VisualAlert.none, AudibleAlert.prompt, .1),
   },
 
diff --git a/selfdrive/controls/lib/lateral_planner.py b/selfdrive/controls/lib/lateral_planner.py
index 932ad49535370..e2d185f0e1f08 100644
--- a/selfdrive/controls/lib/lateral_planner.py
+++ b/selfdrive/controls/lib/lateral_planner.py
@@ -15,13 +15,13 @@
 
 PATH_COST = 1.0
 LATERAL_MOTION_COST = 0.11
-LATERAL_ACCEL_COST = 0.0
+LATERAL_ACCEL_COST = 1.0
 LATERAL_JERK_COST = 0.05
 # Extreme steering rate is unpleasant, even
 # when it does not cause bad jerk.
 # TODO this cost should be lowered when low
 # speed lateral control is stable on all cars
-STEERING_RATE_COST = 800.0
+STEERING_RATE_COST = 8.0
 
 
 class LateralPlanner:
diff --git a/selfdrive/controls/lib/longitudinal_planner.py b/selfdrive/controls/lib/longitudinal_planner.py
index a0f6318323749..786fcfddf78b7 100755
--- a/selfdrive/controls/lib/longitudinal_planner.py
+++ b/selfdrive/controls/lib/longitudinal_planner.py
@@ -60,7 +60,7 @@ def __init__(self, CP, init_v=0.0, init_a=0.0):
     self.solverExecutionTime = 0.0
 
   @staticmethod
-  def parse_model(model_msg, model_error):
+  def parse_model(model_msg, model_error, v_ego):
     if (len(model_msg.position.x) == 33 and
        len(model_msg.velocity.x) == 33 and
        len(model_msg.acceleration.x) == 33):
@@ -73,6 +73,10 @@ def parse_model(model_msg, model_error):
       v = np.zeros(len(T_IDXS_MPC))
       a = np.zeros(len(T_IDXS_MPC))
       j = np.zeros(len(T_IDXS_MPC))
+    max_lat_accel = interp(v_ego, [5, 10, 20], [1.5, 2.0, 3.0])
+    curvatures = np.interp(T_IDXS_MPC, T_IDXS, model_msg.orientationRate.z) / np.clip(v, 0.3, 100.0)
+    max_v = np.sqrt(max_lat_accel / (np.abs(curvatures) + 1e-3)) - 2.0
+    v = np.minimum(max_v, v)
     return x, v, a, j
 
   def update(self, sm):
@@ -121,7 +125,7 @@ def update(self, sm):
     self.mpc.set_weights(prev_accel_constraint)
     self.mpc.set_accel_limits(accel_limits_turns[0], accel_limits_turns[1])
     self.mpc.set_cur_state(self.v_desired_filter.x, self.a_desired)
-    x, v, a, j = self.parse_model(sm['modelV2'], self.v_model_error)
+    x, v, a, j = self.parse_model(sm['modelV2'], self.v_model_error, v_ego)
     self.mpc.update(sm['carState'], sm['radarState'], v_cruise, x, v, a, j)
 
     self.v_desired_trajectory = np.interp(T_IDXS[:CONTROL_N], T_IDXS_MPC, self.mpc.v_solution)
diff --git a/selfdrive/manager/process_config.py b/selfdrive/manager/process_config.py
index c03e995497550..de37e505231d2 100644
--- a/selfdrive/manager/process_config.py
+++ b/selfdrive/manager/process_config.py
@@ -32,8 +32,8 @@ def logging(started, params, CP: car.CarParams) -> bool:
   NativeProcess("encoderd", "selfdrive/loggerd", ["./encoderd"]),
   NativeProcess("loggerd", "selfdrive/loggerd", ["./loggerd"], onroad=False, callback=logging),
   NativeProcess("modeld", "selfdrive/modeld", ["./modeld"]),
-  NativeProcess("mapsd", "selfdrive/navd", ["./map_renderer"], enabled=False),
-  NativeProcess("navmodeld", "selfdrive/modeld", ["./navmodeld"], enabled=False),
+  NativeProcess("mapsd", "selfdrive/navd", ["./map_renderer"]),
+  NativeProcess("navmodeld", "selfdrive/modeld", ["./navmodeld"]),
   NativeProcess("sensord", "selfdrive/sensord", ["./sensord"], enabled=not PC),
   NativeProcess("ubloxd", "selfdrive/locationd", ["./ubloxd"], enabled=(not PC or WEBCAM)),
   NativeProcess("ui", "selfdrive/ui", ["./ui"], offroad=True, watchdog_max_dt=(5 if not PC else None)),
diff --git a/selfdrive/modeld/modeld.cc b/selfdrive/modeld/modeld.cc
index 0a8a8d6358a52..8b459531fb2db 100644
--- a/selfdrive/modeld/modeld.cc
+++ b/selfdrive/modeld/modeld.cc
@@ -61,7 +61,7 @@ mat3 update_calibration(Eigen::Vector3d device_from_calib_euler, bool wide_camer
 void run_model(ModelState &model, VisionIpcClient &vipc_client_main, VisionIpcClient &vipc_client_extra, bool main_wide_camera, bool use_extra_client) {
   // messaging
   PubMaster pm({"modelV2", "cameraOdometry"});
-  SubMaster sm({"lateralPlan", "roadCameraState", "liveCalibration", "driverMonitoringState"});
+  SubMaster sm({"lateralPlan", "roadCameraState", "liveCalibration", "driverMonitoringState", "navModel"});
 
   // setup filter to track dropped frames
   FirstOrderFilter frame_dropped_filter(0., 10., 1. / MODEL_FREQ);
@@ -131,6 +131,12 @@ void run_model(ModelState &model, VisionIpcClient &vipc_client_main, VisionIpcCl
       model_transform_extra = update_calibration(device_from_calib_euler, true, true);
       live_calib_seen = true;
     }
+    if (sm.updated("navModel")) {
+      auto nav_model_features = sm["navModel"].getNavModel().getFeatures();
+      for (int i=0; i<NAV_FEATURE_LEN; i++) {
+        nav_features[i] = nav_model_features[i];
+      }
+    }
 
     float vec_desire[DESIRE_LEN] = {0};
     if (desire >= 0 && desire < DESIRE_LEN) {
diff --git a/selfdrive/modeld/models/driving.h b/selfdrive/modeld/models/driving.h
index 5734c68cb998a..a2a0dfcc7f817 100644
--- a/selfdrive/modeld/models/driving.h
+++ b/selfdrive/modeld/models/driving.h
@@ -4,6 +4,7 @@
 #define TEMPORAL
 #define DESIRE
 #define TRAFFIC_CONVENTION
+#define DRIVING_STYLE
 
 #include <array>
 #include <memory>
diff --git a/selfdrive/modeld/models/nav.h b/selfdrive/modeld/models/nav.h
index b2955ad2c5048..213f5091eb362 100644
--- a/selfdrive/modeld/models/nav.h
+++ b/selfdrive/modeld/models/nav.h
@@ -7,6 +7,8 @@
 #include "selfdrive/modeld/models/commonmodel.h"
 #include "selfdrive/modeld/runners/run.h"
 
+#define NAV // TODO: This should probably be defined in the sconscript or something
+
 constexpr int NAV_INPUT_SIZE = 256*256;
 constexpr int NAV_FEATURE_LEN = 64;
 constexpr int NAV_DESIRE_LEN = 32;
diff --git a/selfdrive/modeld/models/navmodel.onnx b/selfdrive/modeld/models/navmodel.onnx
index 397b8d90e2f64..53089836d3cdb 100644
--- a/selfdrive/modeld/models/navmodel.onnx
+++ b/selfdrive/modeld/models/navmodel.onnx
@@ -1,3 +1,3 @@
 version https://git-lfs.github.com/spec/v1
-oid sha256:9028b36a591763724e95205b48f37f09260b4434fb1f3c6f228db1710a401aa8
-size 12258591
+oid sha256:f851f19b0a9e2299639f18856e4879ee863918227b7cef6a07eb6b94a273a9aa
+size 12259173
diff --git a/selfdrive/modeld/models/navmodel_q.dlc b/selfdrive/modeld/models/navmodel_q.dlc
index 984cf0a553014..8e86d2272a1f4 100644
--- a/selfdrive/modeld/models/navmodel_q.dlc
+++ b/selfdrive/modeld/models/navmodel_q.dlc
@@ -1,3 +1,3 @@
 version https://git-lfs.github.com/spec/v1
-oid sha256:bc7ade56bb4f9525c84a46df22252ea1e321a0518cbcef8bdfc76ccd8ad10b41
+oid sha256:e1c1b277821086fc61b16cb6b68ec3d950d9c2c6ad78f2aa13be88a3a6fa041c
 size 3154304
diff --git a/selfdrive/modeld/models/supercombo.onnx b/selfdrive/modeld/models/supercombo.onnx
index 8805b3dce8d5c..d6da9a6da5f75 100644
--- a/selfdrive/modeld/models/supercombo.onnx
+++ b/selfdrive/modeld/models/supercombo.onnx
@@ -1,3 +1,3 @@
 version https://git-lfs.github.com/spec/v1
-oid sha256:db746e3753de84367595fedd089c2bd41b06bd401ea28e085663533d0e63d74b
-size 45962473
+oid sha256:f794d65ddfb3600e0b3f7d7e894d1dd278b88569de863aae41246eec43f035cf
+size 46040391
diff --git a/selfdrive/modeld/runners/thneedmodel.cc b/selfdrive/modeld/runners/thneedmodel.cc
index 4fdd7ca466f08..61c888cb62b4f 100644
--- a/selfdrive/modeld/runners/thneedmodel.cc
+++ b/selfdrive/modeld/runners/thneedmodel.cc
@@ -41,13 +41,13 @@ void ThneedModel::addExtra(float *extra_input_buf, int buf_size) {
 }
 
 void* ThneedModel::getInputBuf() {
-  if (use_extra && thneed->input_clmem.size() > 4) return &(thneed->input_clmem[4]);
-  else if (!use_extra && thneed->input_clmem.size() > 3) return &(thneed->input_clmem[3]);
+  if (use_extra && thneed->input_clmem.size() > 6) return &(thneed->input_clmem[6]);
+  else if (!use_extra && thneed->input_clmem.size() > 5) return &(thneed->input_clmem[5]);
   else return nullptr;
 }
 
 void* ThneedModel::getExtraBuf() {
-  if (thneed->input_clmem.size() > 3) return &(thneed->input_clmem[3]);
+  if (thneed->input_clmem.size() > 5) return &(thneed->input_clmem[5]);
   else return nullptr;
 }
 
@@ -55,10 +55,10 @@ void ThneedModel::execute() {
   if (!recorded) {
     thneed->record = true;
     if (use_extra) {
-      float *inputs[5] = {recurrent, trafficConvention, desire, extra, input};
+      float *inputs[7] = {recurrent, navFeatures, drivingStyle, trafficConvention, desire, extra, input};
       thneed->copy_inputs(inputs);
     } else {
-      float *inputs[4] = {recurrent, trafficConvention, desire, input};
+      float *inputs[6] = {recurrent, navFeatures, drivingStyle, trafficConvention, desire, input};
       thneed->copy_inputs(inputs);
     }
     thneed->clexec();
@@ -68,10 +68,10 @@ void ThneedModel::execute() {
     recorded = true;
   } else {
     if (use_extra) {
-      float *inputs[5] = {recurrent, trafficConvention, desire, extra, input};
+      float *inputs[7] = {recurrent, navFeatures, drivingStyle, trafficConvention, desire, extra, input};
       thneed->execute(inputs, output);
     } else {
-      float *inputs[4] = {recurrent, trafficConvention, desire, input};
+      float *inputs[6] = {recurrent, navFeatures, drivingStyle, trafficConvention, desire, input};
       thneed->execute(inputs, output);
     }
   }
