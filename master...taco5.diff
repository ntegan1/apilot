diff --git a/selfdrive/controls/lib/lateral_planner.py b/selfdrive/controls/lib/lateral_planner.py
index 932ad49535370..e2d185f0e1f08 100644
--- a/selfdrive/controls/lib/lateral_planner.py
+++ b/selfdrive/controls/lib/lateral_planner.py
@@ -15,13 +15,13 @@
 
 PATH_COST = 1.0
 LATERAL_MOTION_COST = 0.11
-LATERAL_ACCEL_COST = 0.0
+LATERAL_ACCEL_COST = 1.0
 LATERAL_JERK_COST = 0.05
 # Extreme steering rate is unpleasant, even
 # when it does not cause bad jerk.
 # TODO this cost should be lowered when low
 # speed lateral control is stable on all cars
-STEERING_RATE_COST = 800.0
+STEERING_RATE_COST = 8.0
 
 
 class LateralPlanner:
diff --git a/selfdrive/controls/lib/longitudinal_planner.py b/selfdrive/controls/lib/longitudinal_planner.py
index a0f6318323749..786fcfddf78b7 100755
--- a/selfdrive/controls/lib/longitudinal_planner.py
+++ b/selfdrive/controls/lib/longitudinal_planner.py
@@ -60,7 +60,7 @@ def __init__(self, CP, init_v=0.0, init_a=0.0):
     self.solverExecutionTime = 0.0
 
   @staticmethod
-  def parse_model(model_msg, model_error):
+  def parse_model(model_msg, model_error, v_ego):
     if (len(model_msg.position.x) == 33 and
        len(model_msg.velocity.x) == 33 and
        len(model_msg.acceleration.x) == 33):
@@ -73,6 +73,10 @@ def parse_model(model_msg, model_error):
       v = np.zeros(len(T_IDXS_MPC))
       a = np.zeros(len(T_IDXS_MPC))
       j = np.zeros(len(T_IDXS_MPC))
+    max_lat_accel = interp(v_ego, [5, 10, 20], [1.5, 2.0, 3.0])
+    curvatures = np.interp(T_IDXS_MPC, T_IDXS, model_msg.orientationRate.z) / np.clip(v, 0.3, 100.0)
+    max_v = np.sqrt(max_lat_accel / (np.abs(curvatures) + 1e-3)) - 2.0
+    v = np.minimum(max_v, v)
     return x, v, a, j
 
   def update(self, sm):
@@ -121,7 +125,7 @@ def update(self, sm):
     self.mpc.set_weights(prev_accel_constraint)
     self.mpc.set_accel_limits(accel_limits_turns[0], accel_limits_turns[1])
     self.mpc.set_cur_state(self.v_desired_filter.x, self.a_desired)
-    x, v, a, j = self.parse_model(sm['modelV2'], self.v_model_error)
+    x, v, a, j = self.parse_model(sm['modelV2'], self.v_model_error, v_ego)
     self.mpc.update(sm['carState'], sm['radarState'], v_cruise, x, v, a, j)
 
     self.v_desired_trajectory = np.interp(T_IDXS[:CONTROL_N], T_IDXS_MPC, self.mpc.v_solution)
diff --git a/selfdrive/manager/process_config.py b/selfdrive/manager/process_config.py
index c03e995497550..de37e505231d2 100644
--- a/selfdrive/manager/process_config.py
+++ b/selfdrive/manager/process_config.py
@@ -32,8 +32,8 @@ def logging(started, params, CP: car.CarParams) -> bool:
   NativeProcess("encoderd", "selfdrive/loggerd", ["./encoderd"]),
   NativeProcess("loggerd", "selfdrive/loggerd", ["./loggerd"], onroad=False, callback=logging),
   NativeProcess("modeld", "selfdrive/modeld", ["./modeld"]),
-  NativeProcess("mapsd", "selfdrive/navd", ["./map_renderer"], enabled=False),
-  NativeProcess("navmodeld", "selfdrive/modeld", ["./navmodeld"], enabled=False),
+  NativeProcess("mapsd", "selfdrive/navd", ["./map_renderer"]),
+  NativeProcess("navmodeld", "selfdrive/modeld", ["./navmodeld"]),
   NativeProcess("sensord", "selfdrive/sensord", ["./sensord"], enabled=not PC),
   NativeProcess("ubloxd", "selfdrive/locationd", ["./ubloxd"], enabled=(not PC or WEBCAM)),
   NativeProcess("ui", "selfdrive/ui", ["./ui"], offroad=True, watchdog_max_dt=(5 if not PC else None)),
diff --git a/selfdrive/modeld/modeld.cc b/selfdrive/modeld/modeld.cc
index 0a8a8d6358a52..8b459531fb2db 100644
--- a/selfdrive/modeld/modeld.cc
+++ b/selfdrive/modeld/modeld.cc
@@ -61,7 +61,7 @@ mat3 update_calibration(Eigen::Vector3d device_from_calib_euler, bool wide_camer
 void run_model(ModelState &model, VisionIpcClient &vipc_client_main, VisionIpcClient &vipc_client_extra, bool main_wide_camera, bool use_extra_client) {
   // messaging
   PubMaster pm({"modelV2", "cameraOdometry"});
-  SubMaster sm({"lateralPlan", "roadCameraState", "liveCalibration", "driverMonitoringState"});
+  SubMaster sm({"lateralPlan", "roadCameraState", "liveCalibration", "driverMonitoringState", "navModel"});
 
   // setup filter to track dropped frames
   FirstOrderFilter frame_dropped_filter(0., 10., 1. / MODEL_FREQ);
@@ -131,6 +131,12 @@ void run_model(ModelState &model, VisionIpcClient &vipc_client_main, VisionIpcCl
       model_transform_extra = update_calibration(device_from_calib_euler, true, true);
       live_calib_seen = true;
     }
+    if (sm.updated("navModel")) {
+      auto nav_model_features = sm["navModel"].getNavModel().getFeatures();
+      for (int i=0; i<NAV_FEATURE_LEN; i++) {
+        nav_features[i] = nav_model_features[i];
+      }
+    }
 
     float vec_desire[DESIRE_LEN] = {0};
     if (desire >= 0 && desire < DESIRE_LEN) {
diff --git a/selfdrive/modeld/models/driving.h b/selfdrive/modeld/models/driving.h
index 5734c68cb998a..a2a0dfcc7f817 100644
--- a/selfdrive/modeld/models/driving.h
+++ b/selfdrive/modeld/models/driving.h
@@ -4,6 +4,7 @@
 #define TEMPORAL
 #define DESIRE
 #define TRAFFIC_CONVENTION
+#define DRIVING_STYLE
 
 #include <array>
 #include <memory>
diff --git a/selfdrive/modeld/models/nav.h b/selfdrive/modeld/models/nav.h
index b2955ad2c5048..213f5091eb362 100644
--- a/selfdrive/modeld/models/nav.h
+++ b/selfdrive/modeld/models/nav.h
@@ -7,6 +7,8 @@
 #include "selfdrive/modeld/models/commonmodel.h"
 #include "selfdrive/modeld/runners/run.h"
 
+#define NAV // TODO: This should probably be defined in the sconscript or something
+
 constexpr int NAV_INPUT_SIZE = 256*256;
 constexpr int NAV_FEATURE_LEN = 64;
 constexpr int NAV_DESIRE_LEN = 32;
diff --git a/selfdrive/modeld/models/navmodel.onnx b/selfdrive/modeld/models/navmodel.onnx
index 397b8d90e2f64..53089836d3cdb 100644
--- a/selfdrive/modeld/models/navmodel.onnx
+++ b/selfdrive/modeld/models/navmodel.onnx
@@ -1,3 +1,3 @@
 version https://git-lfs.github.com/spec/v1
-oid sha256:9028b36a591763724e95205b48f37f09260b4434fb1f3c6f228db1710a401aa8
-size 12258591
+oid sha256:f851f19b0a9e2299639f18856e4879ee863918227b7cef6a07eb6b94a273a9aa
+size 12259173
diff --git a/selfdrive/modeld/models/navmodel_q.dlc b/selfdrive/modeld/models/navmodel_q.dlc
index 984cf0a553014..8e86d2272a1f4 100644
--- a/selfdrive/modeld/models/navmodel_q.dlc
+++ b/selfdrive/modeld/models/navmodel_q.dlc
@@ -1,3 +1,3 @@
 version https://git-lfs.github.com/spec/v1
-oid sha256:bc7ade56bb4f9525c84a46df22252ea1e321a0518cbcef8bdfc76ccd8ad10b41
+oid sha256:e1c1b277821086fc61b16cb6b68ec3d950d9c2c6ad78f2aa13be88a3a6fa041c
 size 3154304
diff --git a/selfdrive/modeld/models/supercombo.onnx b/selfdrive/modeld/models/supercombo.onnx
index 8805b3dce8d5c..d6da9a6da5f75 100644
--- a/selfdrive/modeld/models/supercombo.onnx
+++ b/selfdrive/modeld/models/supercombo.onnx
@@ -1,3 +1,3 @@
 version https://git-lfs.github.com/spec/v1
-oid sha256:db746e3753de84367595fedd089c2bd41b06bd401ea28e085663533d0e63d74b
-size 45962473
+oid sha256:f794d65ddfb3600e0b3f7d7e894d1dd278b88569de863aae41246eec43f035cf
+size 46040391
diff --git a/selfdrive/modeld/runners/thneedmodel.cc b/selfdrive/modeld/runners/thneedmodel.cc
index 4fdd7ca466f08..61c888cb62b4f 100644
--- a/selfdrive/modeld/runners/thneedmodel.cc
+++ b/selfdrive/modeld/runners/thneedmodel.cc
@@ -41,13 +41,13 @@ void ThneedModel::addExtra(float *extra_input_buf, int buf_size) {
 }
 
 void* ThneedModel::getInputBuf() {
-  if (use_extra && thneed->input_clmem.size() > 4) return &(thneed->input_clmem[4]);
-  else if (!use_extra && thneed->input_clmem.size() > 3) return &(thneed->input_clmem[3]);
+  if (use_extra && thneed->input_clmem.size() > 6) return &(thneed->input_clmem[6]);
+  else if (!use_extra && thneed->input_clmem.size() > 5) return &(thneed->input_clmem[5]);
   else return nullptr;
 }
 
 void* ThneedModel::getExtraBuf() {
-  if (thneed->input_clmem.size() > 3) return &(thneed->input_clmem[3]);
+  if (thneed->input_clmem.size() > 5) return &(thneed->input_clmem[5]);
   else return nullptr;
 }
 
@@ -55,10 +55,10 @@ void ThneedModel::execute() {
   if (!recorded) {
     thneed->record = true;
     if (use_extra) {
-      float *inputs[5] = {recurrent, trafficConvention, desire, extra, input};
+      float *inputs[7] = {recurrent, navFeatures, drivingStyle, trafficConvention, desire, extra, input};
       thneed->copy_inputs(inputs);
     } else {
-      float *inputs[4] = {recurrent, trafficConvention, desire, input};
+      float *inputs[6] = {recurrent, navFeatures, drivingStyle, trafficConvention, desire, input};
       thneed->copy_inputs(inputs);
     }
     thneed->clexec();
@@ -68,10 +68,10 @@ void ThneedModel::execute() {
     recorded = true;
   } else {
     if (use_extra) {
-      float *inputs[5] = {recurrent, trafficConvention, desire, extra, input};
+      float *inputs[7] = {recurrent, navFeatures, drivingStyle, trafficConvention, desire, extra, input};
       thneed->execute(inputs, output);
     } else {
-      float *inputs[4] = {recurrent, trafficConvention, desire, input};
+      float *inputs[6] = {recurrent, navFeatures, drivingStyle, trafficConvention, desire, input};
       thneed->execute(inputs, output);
     }
   }
